name: SubDimensionHUD

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: manual
    spacefueltank:
        class: SpaceFuelContainer
        select: manual
    rocketfueltank:
        class: RocketFuelContainer
        select: manual
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPAtmospheric
        select: all
    radar:
        class: RadarPVPSpace
        select: manual
    databank:
        class: DataBankUnit
    screen:
        class: ScreenUnit
        select: manual
    forcefields:
        class: ManualSwitchUnit
        select: manual


handlers:
    unit:
        start:
            lua: |

                shipName = "Spaceship" --export: name of construct

                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                brakeLock = false
                autoStabilise = false
                stabiliseMode = "off"
                targetPitch = 0

                altitudeHold = false
                targetAltitude = 0

                rocketLaunch = false
                isboosting = false
                boostVelocity = 650

                css = [[
                  <style>
                  .hud {
                    display: flex;
                    flex-direction: column;
                  }
                  .screen {
                    display: flex;
                    flex-direction: column;
                    font-size: 500%;
                    padding-top:20px;
                  }
                  .controls-hud {
                    display: flex;
                    flex-direction: column;
                    justify-content: space-around;
                    background-color: #0d181c88;
                    border-color: #333333;
                    border-radius: 12px;
                    width: 20%;
                    padding: 8px 12px;
                    overflow: none;
                    margin-top:8px;
                  }

                  .controls-hud svg {
                    display:block;
                    margin:0 auto;
                  }

                  h1 {font-size: 120%; color:white; text-transform:uppercase;}
                  h2 {font-size: 100%; color: white; text-transform:uppercase; width: 60%;}

                  .screen h2 {font-size: 150%; margin-bottom: 12px;}
                  .quad h2 {width: 25%;}

                  .line-gauge {
                    font-size:120%;
                    color: white;
                    width: 75%;
                    height: 6px;
                    margin-top:4px;
                    background-color:#aa0016;
                  }

                  .screen .line-gauge {
                    width:60%;
                    height: 18px;
                    margin-top: 8px;
                  }

                  .screen .line-gauge div { height: 18px; }
                  .screen .label {width: auto;}

                  .line-gauge div {
                    height: 6px;
                  }

                  .atmo {background-color:#4c8ba7;}
                  .space {background-color:#fcba12;}
                  .throttle {background-color:#ffffff;}
                  .throttle-bg {background-color:#ffffff66;}

                  .label {
                    font-size: 90%;
                    color: #dddddd;
                    width:25%;
                    padding-left: 1%
                  }
                  .control-container {
                    display: flex;
                    justify-content: space-between;
                    padding: 4px;
                  }
                  .on {
                    background-color: #039bef;
                    margin-left: 10px;
                    border-radius: 50%;
                    width: 12px;
                    height: 12px;
                    border: 1px solid black;
                  }
                  .off {
                    background-color: none;
                    margin-left: 10px;
                    border-radius: 50%;
                    width: 12px;
                    height: 12px;
                    border: 1px solid black;
                  }
                  .none {
                    margin-left: 10px;
                    border-radius: 50%;
                    width: 12px;
                    height: 12px;
                  }
                  .brakeHeld {
                    background-color: orange;
                    margin-left: 10px;
                    border-radius: 50%;
                    width: 12px;
                    height: 12px;
                    border: 1px solid black;
                  }

                  .separator { margin-top: 12px; }
                  </style>]]

                  hudTemplate = [[
                  <head>
                    %s
                  </head>
                  <body>
                  <div class="hud">
                    <h1>%s</h1>
                    <div class="controls-hud">
                      <div class="control-container">
                        <h2>Brake Lock</h2>
                        <div class="label"> [alt-1] </div>
                        <div class="%s"></div>
                      </div>

                      <div class="control-container">
                        <h2>Altitude Hold - %dm</h2>
                        <div class="label"> [alt-2] </div>
                        <div class="%s"></div>
                      </div>

                      %s

                      <div class="control-container separator quad">
                        <h2>Ship Mass</h2>
                        <div class="label"> %.1f t</div>
                      </div>

                      <div class="control-container">
                        <h2>Brake Distance</h2>
                        <div class="label"> %.1f %s</div>
                      </div>

                      %s

                      %s

                      %s

                      <div class="control-container separator">
                        <h2>Damage Report</h2>
                      </div>
                      <div class="control-container separator">
                        %s
                      </div>

                    </div>
                  </div>
                  </body>]]

                  statusTemplate = [[
                  <div class="control-container">
                    <h2>%s</h2>
                    <div class="label"> [alt-%d] </div>
                    <div class="%s"></div>
                  </div>
                  ]]

                  throttleTemplate = [[
                    <div class="control-container separator">
                      <h2>Throttle</h2>
                    </div>
                    <div class="control-container">
                      <div class="line-gauge throttle-bg"><div class="throttle" style="width: %d%%"></div></div> <div class="label">%d%%</div>
                    </div>
                  ]]

                  pitchRollTemplate = [[
                    <div class="control-container quad">
                      <h2>Pitch</h2>
                      <div class="label"> %.1f°</div>
                      <h2>Roll</h2>
                      <div class="label"> %.1f°</div>
                    </div>
                  ]]

                  screenTemplate = [[
                  <div class="screen">

                      %s

                    </div>
                  </div>]]


                  fuelTemplate=[[
                      <div class="control-container">
                        <h2> %s Fuel </h2>
                      </div>
                      %s
                    ]]

                tankTemplate = [[
                <div class="control-container">
                  <div class="line-gauge"><div class="%s" style="width: %d%%"></div></div> <div class="label">%d / %d</div>
                </div>]]

                local realGetMaxKP = core.getMaxKinematicsParametersAlongAxis
                core.getMaxKinematicsParametersAlongAxis = function (...)
                  local result = realGetMaxKP(...)
                  if result[1] < 1 then result[1] = result[3] end
                  if result[2] < 1 then result[2] = result[4] end
                  return result
                end

                function getPitch(gravityDirection, forward, right)
                    local horizontalForward = gravityDirection:cross(right):normalize_inplace()
                    local pitch = math.acos(utils.clamp(horizontalForward:dot(-forward), -1, 1)) * constants.rad2deg
                    if horizontalForward:cross(-forward):dot(right) < 0 then pitch = -pitch end
                    return pitch
                end

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(0)

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                --_autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                --core.show()

                --if gyro ~= nil then gyro.show() end
                --_autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")

                --if atmofueltank_size > 0 then
                --    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                --end
                --if spacefueltank_size > 0 then
                --    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                --end

                --_autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                if radar_1 and string.find(radar_1.getElementClass(), "Space") then
                  _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                end

                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                if antigrav ~= nil then antigrav.show() end
                if warpdrive ~= nil then warpdrive.show() end


                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                -- make sure landing gear exists
                elementsID = core.getElementIdList()
                gearExtended = true
                for k in pairs(elementsID) do
                    local name = core.getElementTypeById(elementsID[k])
                    if (name == "landing gear") then
                        gearExtended = (Nav.control.isAnyLandingGearExtended() == 1)
                    end
                end
                --gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

                -- Set R & T to 1% throttle, mousewheel still 10%
                Nav.axisCommandManager.axisCommands[axisCommandId.longitudinal].throttleAtomicStepValue  = 0.01
                Nav.axisCommandManager.axisCommands[axisCommandId.longitudinal].throttleMouseStepScale  =  10

                if forcefields_1 then
                  forcefields_1.deactivate()
                end

                atmoTanksMax = {}
                atmoTanksCurrent = {}

                spaceTanksMax = {}
                spaceTanksCurrent = {}

                atmoTanksCount = atmofueltank_size
                spaceTanksCount = spacefueltank_size

                for tank=1,atmoTanksCount do
                  atmoTanksMax[tank] = math.floor(atmofueltank[tank].getMaxVolume())
                  atmoTanksCurrent[tank] = math.floor(atmofueltank[tank].getItemsVolume())
                end

                for tank=1,spaceTanksCount do
                  spaceTanksMax[tank] = math.floor(spacefueltank[tank].getMaxVolume())
                  spaceTanksCurrent[tank] = math.floor(spacefueltank[tank].getItemsVolume())
                end

                unit.setTimer("updateTanks", 1) -- one second

                unit.hide()

                local coreHP = core.getMaxHitPoints()
                if coreHP > 10000 then
                    corePositionOffset = 128 * 4
                elseif coreHP > 1000 then
                    corePositionOffset = 64 * 4
                elseif coreHP > 150 then
                    corePositionOffset = 32 * 4
                else
                    corePositionOffset = 16 * 4
                end


                elementsID = core.getElementIdList()
                dmgReport = [[<svg version="1.1"
                baseProfile="full"
                width="320" height="200"
                xmlns="http://www.w3.org/2000/svg">

                %s

                %s

                </svg>]]

                genericElementTemplate = [[<circle cx="%.2f" cy="%.2f" r="3" fill="%s" />]]
                atmoEngineTemplate = [[<svg x="%.2f" y="%.2f"><g style="fill:%s;stroke:#000000;stroke-width:1.5px;">
                  <path d="M 5.5146787,1.0064811 H 7.3088078 V 0.1322915 H 9.1029365 V 1.0064811 H 10.897066 V 0.1322915 h 1.794129 v 0.8741896 h 1.794127 l 5.382386,5.2451415 v 3.4967587 l -5.382386,5.2451377 h -1.794127 v 0.87419 h -1.794129 v -0.87419 H 9.1029365 v 0.87419 H 7.3088078 v -0.87419 H 5.5146787 L 0.1322915,9.7483813 V 6.2516226 Z" />
                  <path d="M 7.3088078,1.0064819 V 14.993519" />
                  <path d="M 9.1029365,1.0064819 V 14.993519" />
                  <path d="M 10.897066,1.0064811 V 14.993519" />
                  <path d="M 12.691195,1.0064819 V 14.993519" />
                </g></svg>]]
                spaceEngineTemplate = [[<svg x="%.2f" y="%.2f"><g style="fill:%s;stroke:#000000;stroke-width:1.5px;">
                  <path d="m 6.0108896,1.0064809 h 1.959533 V 0.1322915 H 9.9299543 V 1.0064809 H 11.88949 V 0.1322915 h 1.959533 v 0.8741894 l 0.140086,5.2362854 5.878599,-5.24513944 V 14.984664 L 13.989109,9.7395241 13.849023,14.993519 v 0.87419 H 11.88949 v -0.87419 H 9.9299543 v 0.87419 H 7.9704226 v -0.87419 H 6.0108896 L 0.13229149,9.7483797 V 6.2516203 Z" />
                  <path d="M 7.9704226,1.0064809 V 14.993519" />
                  <path d="M 9.9299543,1.0064809 V 14.993519" />
                  <path d="M 11.88949,1.0064809 V 14.993519" />
                  <path d="M 13.849023,1.0064809 V 14.993519" />
                </g></svg>]]
                airBrakeTemplate = [[<svg x="%.2f" y="%.2f"><g style="fill:%s;stroke:#000000;stroke-width:1.5px;">
                  <path d="M 19.867708,4.6322915 H 17.245685 L 15.875,2.6458333 h -2.645833 l -1.29756,1.9864582 H 7.9711159 L 6.6145833,2.6458333 H 3.96875 L 2.6069058,4.6322915 H 0.1322915 V 6.7900556 H 1.2287029 V 8.9478227 H 0.1322915 V 11.105588 H 2.6069058 L 3.96875,13.229167 h 2.6458333 l 1.4066654,-2.123579 h 3.9103583 l 1.29756,2.123579 H 15.875 l 1.220286,-2.123579 h 2.772422 V 8.9478227 H 18.771296 V 6.7900556 h 1.096412 V 4.6322915" />
                  <path d="M 1.2287029,6.7900554 H 18.771296 V 8.9478225 H 1.2287029 Z" />
                </g></svg>]]
                spaceBrakeTemplate = [[<svg x="%.2f" y="%.2f"><g style="fill:%s;stroke:#000000;stroke-width:1.5px;">
                  <path d="M 19.867708,4.6322915 H 17.245685 L 14.552083,2.6458333 11.931607,4.6322915 H 7.9711159 L 5.2916667,2.6458333 2.6069058,4.6322915 H 0.1322915 V 6.7900556 H 1.2287029 V 8.9478227 H 0.1322915 v 2.1577653 h 2.4746143 l 2.6847609,2.123579 2.729582,-2.123579 h 3.9103583 l 2.620476,2.123579 2.543203,-2.123579 h 2.772422 V 8.9478227 H 18.771296 V 6.7900556 h 1.096412 V 4.6322915" />
                  <path d="M 1.2287029,6.7900554 H 18.771296 V 8.9478225 H 1.2287029 Z" />
                </g></svg>]]
                adjustorTemplate = [[<svg x="%.2f" y="%.2f"><g style="fill:%s;stroke:#000000;stroke-width:1.5px;">
                  <path d="M 19.917842,8.5728619 11.75846,8.5741619 17.0036,2.695563 H 3.0165627 l 5.245139,5.8785989 -8.0792774,-0.0013 v 2.1577641 h 1.0964114 v 2.157767 H 0.1824243 v 2.157765 H 19.917842 V 12.888393 H 18.82143 v -2.157767 h 1.096412 V 8.5728619" />
                  <path d="M 1.2788357,10.730626 H 18.82143 v 2.157767 H 1.2788357 Z" />
                </g></svg>]]
                customElementTemplate = [[<svg x="%.2f" y="%.2f"><g style="fill:%s;stroke:#000000;stroke-width:1.5px;">
                  <path d="" />
                </g></svg>]]
                yOffset = 0 --export; Damage Report Y Offset
                xScale = 1 --export; Damage Report X Scale
                yScale = 1 --export; Damage Report Y Scale

                svgPixelWidth = 300/100
                svgPixelHeight = 200/100

                function updateDMGReport()

                    local elements = ""

                    local broken_count = 0
                    local broken_elements = ""

                    for _,id in pairs(elementsID) do
                        local max_hp = core.getElementMaxHitPointsById(id)
                        local curr_hp = core.getElementHitPointsById(id)

                        local name = core.getElementNameById(id)

                        local position = core.getElementPositionById(id)
                        local vector_position = vec3(position)
                        elemPos = {}
                        elemPos.x = ( 50 + ( ( ( ((vector_position.x*4) - corePositionOffset) * xScale ) / corePositionOffset ) * 100) ) * svgPixelWidth
                	      elemPos.y = (( 50 - ( ( ( ((vector_position.y*4) - corePositionOffset) * yScale ) / corePositionOffset ) * 100) ) - yOffset) * svgPixelHeight
                	      --elemPos.z = math.floor( ( ((vector_position.z*4) - corePositionOffset)  ) )

                        local elementType = core.getElementTypeById(id)
                        local elementTemplate = genericElementTemplate
                        if string.find(elementType, "Atmospheric Engine") then
                            elemPos.x = elemPos.x-10
                            elemPos.y = elemPos.y-8
                            elementTemplate = atmoEngineTemplate
                        elseif string.find(elementType, "Space Engine") then
                            elemPos.x = elemPos.x-10
                            elemPos.y = elemPos.y-8
                            elementTemplate = spaceEngineTemplate
                        elseif string.find(elementType, "Airbrake") then
                            elemPos.x = elemPos.x-10
                            elemPos.y = elemPos.y-8
                            elementTemplate = airBrakeTemplate
                        elseif string.find(elementType, "Retro") then
                            elemPos.x = elemPos.x-10
                            elemPos.y = elemPos.y-8
                            elementTemplate = spaceBrakeTemplate
                        elseif string.find(elementType, "Adjustor") then
                            elemPos.x = elemPos.x-10
                            elemPos.y = elemPos.y-8
                            elementTemplate = adjustorTemplate
                        --elseif string.find(elementType, "xxx") then
                          --system.print(elementType)
                        end

                        if curr_hp == 0 then
                            broken_count = broken_count + 1
                            broken_elements = broken_elements .. string.format(elementTemplate, elemPos.x, elemPos.y, "red")
                        elseif curr_hp < max_hp then
                            broken_count = broken_count + 1
                            broken_elements = broken_elements .. string.format(elementTemplate, elemPos.x, elemPos.y, "orange")
                        else
                            elements = elements .. string.format(elementTemplate, elemPos.x, elemPos.y, "green")
                        end

                    end

                    damageReport = string.format(dmgReport, elements, broken_elements)
                end

                brakingDistance = 0
                brakingDistanceUnit = "km"
                function calculateBrakingDistance()
                  local speed = vec3.new(core.getVelocity()):len()
                  local mass = core.getConstructMass()
                  local maxBrakingForce = json.decode(unit.getData()).maxBrake
                  if not maxBrakingForce then
                    brakingDistance = 0
                    brakingDistanceUnit = "km"
                    return
                  end

                  local c = (30000*1000)/3600
                  local cSq = c*c
                  local totA = -maxBrakingForce * (1 / mass)

                  local k1 = c * math.asin( speed / c)
                  local k2 = cSq * math.cos(k1 / c) / totA
                  local t = -k1 / totA
                  local d = k2 - cSq * math.cos( (totA*t + k1) / c ) / totA
                  local d_su = d / 200000

                  if d_su < 0.5 then
                    brakingDistance = d / 1000
                    brakingDistanceUnit = "km"
                  else
                    brakingDistance = d_su
                    brakingDistanceUnit = "su"
                  end

                end

                updateDMGReport()
                unit.setTimer("updateDMG", 15) -- 15 seconds

                calculateBrakingDistance()
                unit.setTimer("updateBraking", 1) -- 30 seconds


        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                --Nav.control.switchOffHeadlights()

                if forcefields_1 then
                  forcefields_1.activate()
                end

        tick:
          args: ["updateTanks"]
          lua: |
            for tank=1,atmoTanksCount do
              atmoTanksCurrent[tank] = math.floor(atmofueltank[tank].getItemsVolume())
            end

            for tank=1,spaceTanksCount do
              spaceTanksCurrent[tank] = math.floor(spacefueltank[tank].getItemsVolume())
            end

        tick:
          args: ["updateDMG"]
          lua: |
            updateDMGReport()

        tick:
          args: ["updateBraking"]
          lua: |
            calculateBrakingDistance()

    system:
        start:
            lua: |

                system.setScreen('HUD Error')
                screenOn = 1
                system.showScreen(screenOn)

        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  3 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                if brakeLock then
                  brakeInput = 1
                end

                --local vel = vec3(core.getVelocity()):len()

                --system.print(gyro and "gyro" or "no gyro  ")
                if altitudeHold then
                    autoStabilise = true
                    stabiliseMode = "alt"
                    pitchInput = 0
                    local altitude = core.getAltitude()
                    local velocity = vec3(core.getWorldVelocity())
                    local velMag = vec3(velocity):len()

                    local altDiff = targetAltitude - altitude
                    local MaxPitch = 20

                    local minmax = 500 + velMag
                    local targetPitch = (utils.smoothstep(altDiff, -minmax, minmax) - 0.5)*2*MaxPitch
                end

                if autoStabilise then

                  local worldV = vec3(core.getWorldVertical())
                  local constrF = vec3(core.getConstructWorldOrientationForward())
                  local constrR = vec3(core.getConstructWorldOrientationRight())

                  local roll = getRoll(worldV, constrF, constrR)
                  local targetRoll = 0

                  if (rollPID == nil) then
                      rollPID = pid.new(6 * 0.01, 0, 6 * 0.02)
                  end
                  rollPID:inject(targetRoll - roll)
                  local autoRollInput = rollPID:get()

                  rollInput = autoRollInput

                  local pitch = getPitch(worldV, constrF, constrR)
                  --local targetPitch = 0
                  if (pitchPID == nil) then
                    pitchPID = pid.new(6 * 0.01, 0, 6 * 0.02)
                  end
                  pitchPID:inject(targetPitch - pitch)
                  local autoPitchInput = pitchPID:get()

                  pitchInput = autoPitchInput
                end

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')
                local velocity = vec3(core.getVelocity())
                local speed = velocity:len()
                if (velocity.z < 0) then
                  speed = -speed
                end

                -- vec3(core.getWorldVelocity()):dot(-vec3(core.getWorldVertical()))

                local cc_speed = boostVelocity; --Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)

                if( speed * 3.6 > cc_speed) then
                  unit.setEngineThrust('rocket_engine',0)
                elseif (isboosting) then
                  unit.setEngineThrust('rocket_engine',1)
                end

        update:
            lua: |
              Nav:update()

              local pitchRollHTML = ""
              local worldV = vec3(core.getWorldVertical())
              local constrF = vec3(core.getConstructWorldOrientationForward())
              local constrR = vec3(core.getConstructWorldOrientationRight())

              local roll = getRoll(worldV, constrF, constrR)
              local pitch = getPitch(worldV, constrF, constrR)
              pitchRollHTML = string.format(pitchRollTemplate, pitch, roll)

              local atmoTankHTML = ""
              for tank=1,atmoTanksCount do
                local percentage = math.floor((atmoTanksCurrent[tank] / atmoTanksMax[tank]) * 100)
                atmoTankHTML = atmoTankHTML .. string.format(tankTemplate, "atmo", percentage, atmoTanksCurrent[tank], atmoTanksMax[tank] )
              end

              if atmoTanksCount > 0 then
                atmoTankHTML = string.format(fuelTemplate, "Atmo", atmoTankHTML)
              end

              local spaceTankHTML = ""
              for tank=1,spaceTanksCount do
                local percentage = math.floor((spaceTanksCurrent[tank] / spaceTanksMax[tank]) * 100)
                spaceTankHTML = spaceTankHTML .. string.format(tankTemplate, "space", percentage, spaceTanksCurrent[tank], spaceTanksMax[tank] )
              end

              if spaceTanksCount > 0 then
                spaceTankHTML = string.format(fuelTemplate, "Space", spaceTankHTML)
              end

              local fuelTanksHTML = string.format("%s%s", atmoTankHTML, spaceTankHTML)

              local throttle = math.floor(unit.getThrottle())
              local throttleHTML = string.format(throttleTemplate, throttle, throttle)

              local autoStabiliseHTML = ""
              local title = "Auto Stabilise - " .. stabiliseMode
              autoStabiliseHTML = string.format(statusTemplate, title, 3, (autoStabilise and "on" or "off"))

              local brakeStatus = "off"
              if brakeLock then
                brakeStatus = "on"
              elseif brakeInput > 0 then
                brakeStatus = "brakeHeld"
              end

              system.setScreen(string.format(hudTemplate, css, shipName, brakeStatus, targetAltitude, (altitudeHold and "on" or "off"), autoStabiliseHTML, core.getConstructMass()/1000, brakingDistance, brakingDistanceUnit, pitchRollHTML, throttleHTML, fuelTanksHTML, damageReport ) )

              if screen_1 then
                local screenHTML = string.format(screenTemplate, fuelTanksHTML)
                screen_1.setHTML(css .. screenHTML)
              end

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(0)
                    boostVelocity = -80
                    isboosting = true
                    brakeLock = true
                else
                    Nav.control.retractLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(100)
                    boostVelocity = 650
                    isboosting = true
                    brakeLock = false
                    brakeInput = 0
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = -1 --pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = 0 --pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = 1 --pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = 0 --pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = -1 --rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = 0 --rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = 1 --rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = 0 --rollInput - 1
        actionStart:
            args: [yawright]
            lua: yawInput = -1 --yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = 0 --yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = 1 --yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = 0 --yawInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [brake]
            lua: |
                brakeInput = 1 -- brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end

                if altitudeHold then
                  altitudeHold = false
                end

        actionStop:
            args: [brake]
            lua: |
                brakeInput = 0 --brakeInput - 1
                if brakeLock then
                  brakeLock = false
                end

                if autoStabilise then
                  autoStabilise = false
                  stabiliseMode = "off"
                  targetPitch = 0
                end

                pitchInput = 0
                rollInput = 0

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end

        actionStart:
            args: [booster]
            lua: |
                  --Nav:toggleBoosters()
                  isboosting = not isboosting

                  if(isboosting) then
                    unit.setEngineThrust('rocket_engine',1)
                  else
                    unit.setEngineThrust('rocket_engine',0)
                  end
        actionStart:
              args: [stopengines]
              lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)

        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end
        actionStart:
            args: [warp]
            lua: if warpdrive ~= nil then warpdrive.activateWarp() end

        actionStart:
            args: [option1]
            lua: |
                brakeLock = not brakeLock
                brakeInput = 0

        actionStart:
            args: [option2]
            lua: |
                altitudeHold = not altitudeHold
                if altitudeHold then
                  targetAltitude = math.floor(core.getAltitude() / 100) * 100
                else
                  targetAltitude = 0
                end

        actionStart:
            args: [option3]
            lua: |
                if stabiliseMode == "off" then
                  autoStabilise = true
                  stabiliseMode = "flat"
                  targetPitch = 0
                elseif stabiliseMode == "flat" then
                  autoStabilise = true
                  stabiliseMode = "15°"
                  targetPitch = 15
                elseif stabiliseMode == "15°" then
                  autoStabilise = true
                  stabiliseMode = "25°"
                  targetPitch = 25
                else
                  autoStabilise = false
                  stabiliseMode = "off"
                  targetPitch = 0
                end
                pitchInput = 0
                rollInput = 0
